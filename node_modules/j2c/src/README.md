# ./src

`j2c` is written in a possibly odd JS style. The goals are to provide a JS-backed SASS clone that has a small size, broad compatibilty and reasonable speed.

As a consequence, the lib is written in shimable ES5 strict mode, with ES6 modules that are eliminated at build time with [rollup](), so that `j2c` works in old IE and is as small as possible.

The code is also written with maximal gzippability in mind. It sometimes means favouring code duplication over abstraction, since exact duplicates compress very well. I also implies sometimes large conditional expressions.

Variables are created only to avoid duplicate computation.

This approach is clearly not scalable and bug prone. 

Scalability is not a concern, since I intend `j2c` to remain small. 

Regarding bugs, there's at this point a 4/1 test/code ratio, and 100% test coverage, which allows me to catch a lot of possible mistakes. But most of all, behind the raw for loops and repetitive style lies a clean, functional architecture.

Not counting helpers, `j2c` is built around three almost pure, pattern matching (conceptually), recursive functions. The only side effects are well defined: populate the buffer (an array of strings to be joined to form the final sheet) and populate or query the local name space (for local class and animation names). Every feature is isolated form the rest, which makes it trivial to track down and pinpoint the source of most bugs when they occur. The harder bugs I've had to track were, unsurprisingly, related to the non-pure parts of `j2c`, and especially the class and animation name localization stuff. However, problems usually become evident with a few well placed `console.*()` calls.

`main.js` contains the public API (`j2c.*` functions)

`sheet.js` handles the selectors part of the tree and dispatch to `at-rules` and `declarations` when needed.

`declarations.js`, `at-rules.js` and `helpers.js` are self-explaining. `declaration` is at the heart of `j2c.inline`.

